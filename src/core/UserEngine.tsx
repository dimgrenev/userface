import React from 'react';

let componentRegistry: Record<string, React.FC<any>> = {};
let componentTypes: Record<string, any> = {};

// Функция для извлечения типов пропсов из компонента
const extractComponentProps = (component: React.ComponentType<any>): any => {
  // Пытаемся получить типы из TypeScript
  if (component.propTypes) {
    return component.propTypes;
  }
  
  // Fallback - возвращаем any для JS компонентов
  return 'any';
};

// Функция для обновления реестра компонентов
const updateRegistry = () => {
  const registryContent = `// This file is auto-generated by UserEngine. Do not edit manually.
// Generation timestamp: ${new Date().toISOString()}

// userface - это движок, компоненты регистрируются пользователем
export const componentRegistry = {
${Object.entries(componentRegistry).map(([name, component]) => 
  `  '${name}': ${component.name || 'Component'}`
).join(',\n')}
};

export type ComponentName = keyof typeof componentRegistry;
`;

  // В реальной реализации здесь была бы запись в файл
  console.log('[UserEngine] Updated registry:', registryContent);
  
  // Запускаем генерацию типов
  triggerTypeGeneration();
};

// Функция для запуска генерации типов
const triggerTypeGeneration = () => {
  // В реальной реализации здесь был бы вызов скрипта
  console.log('[UserEngine] Triggering type generation...');
  
  // Имитируем генерацию типов
  const typesContent = `// This file is auto-generated by UserEngine. Do not edit manually.
// Generation timestamp: ${new Date().toISOString()}

import React from 'react';

// Базовый тип для всех спеков
export interface BaseUserFace {
  id: string;
  component: string;
  meta?: {
    className?: string;
    visible?: boolean;
  };
  events?: Record<string, string>;
  [key: string]: any;
}

// UserFace - автоматически генерируется из зарегистрированных компонентов
export type UserFace = BaseUserFace & (${Object.keys(componentRegistry).map(name => 
  `{ component: '${name}'; props: ${name.charAt(0).toUpperCase() + name.slice(1)}Props; }`
).join(' | ') || 'BaseUserFace'});

// Типы для движка
export interface UserEngine {
  registerComponent(name: string, component: React.ComponentType<any>): void;
  getComponent(name: string): React.ComponentType<any> | undefined;
  getRegisteredComponents(): string[];
}

export interface UserRendererProps {
  face: UserFace;
}

export interface UserComponentProps {
  face: UserFace;
  children?: React.ReactNode;
}

// Типы зарегистрированных компонентов
${Object.keys(componentRegistry).map(name => 
  `export type ${name.charAt(0).toUpperCase() + name.slice(1)}Props = any; // TODO: Extract from component`
).join('\n')}
`;

  console.log('[UserEngine] Generated types:', typesContent);
};

export interface UserEngine {
  getComponent: (name: string) => React.ComponentType<any> | undefined;
  registerComponents: (newComponents: Record<string, React.FC<any>>) => void;
  registerComponent: (name: string, component: React.FC<any>) => void;
  getRegisteredComponents: () => string[];
}

const createUserEngine = (): UserEngine => {
  const getComponent = (name: string) => {
    const component = componentRegistry[name];
    if (!component) {
      console.warn(`[UserEngine] Component "${name}" not found in registry.`);
      return undefined;
    }
    return component;
  };

  const registerComponent = (name: string, component: React.FC<any>) => {
    componentRegistry[name] = component;
    componentTypes[name] = extractComponentProps(component);
    
    console.log(`[UserEngine] Component "${name}" registered`);
    console.log(`[UserEngine] Extracted props:`, componentTypes[name]);
    
    // Автоматически обновляем реестр и типы
    updateRegistry();
  };

  const registerComponents = (newComponents: Record<string, React.FC<any>>) => {
    Object.entries(newComponents).forEach(([name, component]) => {
      registerComponent(name, component);
    });
  };

  const getRegisteredComponents = () => {
    return Object.keys(componentRegistry);
  };

  return {
    getComponent,
    registerComponents,
    registerComponent,
    getRegisteredComponents,
  };
};

export const userEngine = createUserEngine(); 